#
#  Class to handle UDP Events from Webrick 6 and later, includes 6.4
#
#  Lawrence Klyne
#
#
import socket, logging, threading
#import sys, string, xml.dom.minidom, urllib
#from socket import socket, AF_INET, SOCK_DGRAM
#from time import time, ctime, sleep

# This feels as if this needs further generalization and the event attributes should be dictionaried.


#
# A template event handler for inbound webbrick packets
# A simple version.
#
class wbEventTarget:
    def handleEvent( self, event ):
        return


# Generic event type
#
#
class WbEvent:
    """
    Generic webbrick/HGA event contains type, source
    """

    def __init__(self, type = None, source = None ):
        self._type = type
        self._source = source
        self._other_data = dict()

    """
    This is a template for an event generated by any source in the HGA
    """
    def type(self):
        """
            returns a string URI that identifies the event type.
            The event type will define what parameters are associated with this event.
        """
        return self._type

    def source(self):
        """
            returns a string URI that identifies the event source
        """
        return self._source


    def other_data(self):
        """
            returns an arbitray object that is other data for this event.
        """
        return self._other_data

    def __str__(self):
        return "%s %s %s" % ( self._type, self._source, self._other_data)
        
class udp6Packet(WbEvent):
    def __init__ (self, adr, data):
        WbEvent.__init__(self)
        logging.debug( 'udp6Packet' )
        self._other_data["ipAdr"] = str(adr[0])
        self._other_data["udpType"] = data[1]
        self._other_data["pktType"] = data[2:4]
        self._type = "%s" % self._other_data["pktType"]
        self._source = "%s" % self._other_data["pktType"]
        if ( self._other_data["pktType"] == "NN" ):
            self._other_data["macAdr"] = [ord(data[4]), ord(data[5]),ord(data[6]),ord(data[7]),ord(data[8]),ord(data[9]) ]
        else:
            self._other_data["srcChannel"] = ord(data[4])
            self._other_data["tgtType"] = ord(data[5]) >> 6
            self._other_data["tgtChannel"] = ord(data[5]) & 0x1F
            self._other_data["action"] = ord(data[6]) & 0xF
            self._other_data["dwell"] = ord(data[6]) >> 4
            self._other_data["fromNode"] = ord(data[7])
            self._other_data["toNode"] = ord(data[8])
            self._other_data["setPoint"] = ord(data[9])
            self._other_data["val"] = (ord(data[10]) * 256) + ord(data[11])
            self._other_data["seqNr"] = ord(data[12])
        logging.debug( 'udpPacket %s ' % (self._other_data) )
        
class udpBinaryPacket(WbEvent):
    def __init__ (self, adr, data):
        WbEvent.__init__(self)
        logging.debug( 'udpBinaryPacket' )
        self._other_data["ipAdr"] = str(adr[0])
        self._other_data["udpType"] = data[1]
        # convert udpType to packet type
        self._other_data["pktType"] = ("%x" % (ord(data[1])))
        self._type = "binary/%s" % self._other_data["pktType"]
        self._source = "%s" % self._other_data["pktType"]
        self._other_data["fromNode"] = ord(data[2])
        self._other_data["seqNr"] = ord(data[3])

        self._other_data["data"] = data[4:ord(data[0])]

        logging.debug( 'udpPacket %s ' % (self._other_data) )

#
# WebBrick UDP event packets
#
class wbUdpEvents2(threading.Thread):

    LOCALHOST = ''
    WBPORT = 2552

    def __init__ (self, eventTgt ):
        self.wbSkt = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.eventTgt = eventTgt
        self.running = True
        threading.Thread.__init__(self)

    # Terminate interface
    def shutdown(self):
        logging.info( 'WebBrick UDP monitor shutdown' )
        self.running = False
        self.wbSkt.close()

    def alive(self):
        return self.isAlive()

    def startMonitor(self):
        # bind socket
        self.wbSkt.bind((self.LOCALHOST, self.WBPORT))
        self.setDaemon( True )
        threading.Thread.start(self)

    def run(self):
        # stay in loop reading packets while socket open.
        logging.debug( 'wbUdpEvents run' )
        while ( self.running ):
            # read packet
            try:
                data = self.wbSkt.recvfrom(32)
                if data:
                    udp = None
                    # create wbUdpEvents
                    # wb 6 UDP packets have a length byte in the first position, use to decide on 5 or 6.
                    logging.debug( 'data %u %u' % (ord(data[0][0]), ord(data[0][1])) )

                    if ( ord(data[0][0]) < 32 ):
                        if ( ord(data[0][1]) >= 32 ):
                            udp = udp6Packet( data[1], data[0] )
                        else:
                            udp = udpBinaryPacket( data[1], data[0] )

                    # call eventTgt method.
                    if udp :
                        self.eventTgt.handleEvent( udp )

                # end if data

            except socket.error, err:
                logging.error( err )
        logging.debug( 'wbUdpEvents stopping' )
                
    